import torch
import syft


class FalconHelper:
    @classmethod
    def unfold(cls, image, kernel_size, padding):
        return cls.__switch_public_private(
            image, cls.__public_unfold, cls.__private_unfold, kernel_size, padding
        )

    @staticmethod
    def __public_unfold(image, kernel_size, padding):
        image = image.double()
        image = torch.nn.functional.unfold(image, kernel_size=kernel_size, padding=padding)
        image = image.long()
        return image

    @staticmethod
    def __private_unfold(image, kernel_size, padding):
        return image.unfold(kernel_size, padding)

    @staticmethod
    def xor(value, other):
        return value + other - (value * 2 * other)

    @staticmethod
    def __switch_public_private(value, public_function, private_function, *args, **kwargs):
        if isinstance(value, (int, float, torch.Tensor, syft.FixedPrecisionTensor)):
            return public_function(value, *args, **kwargs)
        elif isinstance(value, syft.ReplicatedSharingTensor):
            return private_function(value, *args, **kwargs)
        else:
            raise ValueError(
                "expected int, float, torch tensor, or ReplicatedSharingTensor "
                "but got {}".format(type(value))
            )

    @staticmethod
    def select_share(
        b: ReplicatedSharingTensor,
        x: ReplicatedSharingTensor,
        y: ReplicatedSharingTensor,
    ) -> ReplicatedSharingTensor:
        """Select x share or y share depending on b

        Args:
            x (ReplicatedSharingTensor): the first share to select
            y (ReplicatedSharingTensor): the second share to select
            b (ReplicatedSharingTensor): the bit to take into consideration
                when selecting between x or y

        Return:
            x if b == 0 else y
        """

        ring_size = x.ring_size
        players = x.players

        # This should be generated by a crypto provider or create a 0 RST shared value and make
        # each worker add a random number at an offline step
        # (Idea): Use the correlated randomness shared at the beginning
        c = torch.randint(high=2, size=(1,))
        c_2 = c.share(*players, protocol="falcon", field=2)
        c_L = c.share(*players, protocol="falcon", field=ring_size)

        xor_b_c = FalconHelper.xor(b, c_2)

        # TODO: Think of a method to do this better (1 - c_share) without being to
        # "intrusive" with the operation
        ones = torch.ones(size=(1,)).share(*players, protocol="falcon", field=ring_size)
        if xor_b_c.reconstruct().item():
            d = ones - c_L
        else:
            d = c_L

        selected_val = (y - x) * d + x
        return selected_val

    def negate_cond(
        x: ReplicatedSharingTensor, beta: ReplicatedSharingTensor
    ) -> ReplicatedSharingTensor:
        """Performs the computation (-1)^beta * x

        Args:
            x_share (ReplicatedSharingTensor): share to "evaluate"
            beta_share (ReplicatedSharingTensor): the reconstructed value should be in {0, 1}

        Return:
            A RST that is (-1)^beta * x
        """
        ring_size = x.ring_size
        players = x.players
        shape = x.shape

        pow_sh = (
            torch.ones(size=shape).share(*players, protocol="falcon", field=ring_size) - beta * 2
        )
        result = pow_sh * x

        return result
