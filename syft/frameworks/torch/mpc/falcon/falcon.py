import syft
import torch

from syft.frameworks.torch.mpc.falcon.falcon_helper import FalconHelper
from syft.frameworks.torch.tensors.interpreters.replicated_shared import ReplicatedSharingTensor

from typing import List
from syft.workers.base import BaseWorker


def conv2d(filters: syft.ReplicatedSharingTensor, image, padding=0):
    image_batches, image_channels, image_width, image_height = image.shape
    channels_out, filter_channels, filter_width, filter_height = filters.shape
    image = FalconHelper.unfold(image, filter_height, padding)
    filters = filters.view(channels_out, -1)
    result = filters @ image
    output_size = (image_height - filter_height + 2 * padding) + 1
    result = result.view(-1, channels_out, output_size, output_size)
    return result


def select_share(
    b_share: ReplicatedSharingTensor,
    x_share: ReplicatedSharingTensor,
    y_share: ReplicatedSharingTensor,
) -> ReplicatedSharingTensor:
    """Performs select share protocol
    If the bit b_share is 0, x_sh is returned
    If the bit b_share is 1, y_sh is returned

    Args:
        x_share (ReplicatedSharingTensor): the first share to select
        y_share (ReplicatedSharingTensor): the second share to select
        b_share (ReplicatedSharingTensor): the bit to take into consideration
            when selecting between x or y

    Return:
        x_share or y_share (both are ReplicatedSharingTensor): the b_share
        tells us what share to select
    """

    ring_size = x_share.ring_size
    players = x_share.players

    # This should be generated by a crypto provider or create a 0 RST shared value and make
    # each worker add a random number at an offline step
    c = torch.randint(high=2, size=(1,))
    c_share_2 = c.share(*players, protocol="falcon", field=2)
    c_share_L = c.share(*players, protocol="falcon", field=ring_size)

    xor_b_c = FalconHelper.xor(b_share, c_share_2)

    # TODO: Think of a method to do this better (1 - c_share) without being to
    # "intrusive" with the operation
    ones_share = ReplicatedSharingTensor.one_shares(players, ring_size)
    if xor_b_c.reconstruct().item():
        d_share = ones_share - c_share_L
    else:
        d_share = c_share_L

    selected_share = (y_share - x_share) * d_share + x_share
    return selected_share


def evaluate(
    x_share: ReplicatedSharingTensor, beta_share: ReplicatedSharingTensor
) -> ReplicatedSharingTensor:
    """Performs the computation (-1)^beta * x

    Args:
        x_share (ReplicatedSharingTensor): share to "evaluate"
        beta_share (ReplicatedSharingTensor): the reconstructed value should be in {0, 1}

    Return:
        A RST that is (-1)^beta * x
    """
    ring_size = x_share.ring_size
    players = x_share.players
    shape = x_share.shape

    pow_sh = (
        ReplicatedSharingTensor.one_shares(players, ring_size=ring_size, shape=shape)
        - beta_share * 2
    )
    result = pow_sh * x_share

    return result
