"""
 The AST part of syft is responsible for the overall remote call execution. Basically, the AST is a
 tree that maps function call to their exact path and know what to do with that node in the tree.

 Example: We want to append an object to a List, meaning
 that we know where should we find it, so we need to know the following chain:

                globals  <- the global scope or the entry point of execution (hidden)
                   |
                  syft   <- the syft module
                   |
                  lib   <- a submodule of syft
                   |
                  List <- the class we were looking for
                   |
                append <- the method we were looking for

This path has to be solved when doing remote execution as well, this is where the AST comes handy.
The ast is responsible for:

A. Remote execution.
B. Local execution.

A. Remote execution.
Remote execution can be performed only when the AST has been constructed with a client. Check
syft/core/node to be familiar with the roles of clients and nodes. Each valid action on the ast
triggers an Action (GetSetStaticAttributeAction, GetSetPropertyAction, etc. This kind of actions
require: the path on solving the required node (on the above example, the path is
syft.lib.List.append), the object on which to perform it (given by the __self attribute and from
id_at_location if executed on a pointer) and the attributes if needed.

B Local execution.
After a call has been made, the remote execution starts, but we need a local handler for the result
of the remote execution through a Pointer. The AST is responsible to generate all the
permitted methods and attributes on a Pointer and the return type of the performed action.


The existing types of nodes are:
* a Globals, which is the entrypoint of execution, from here you can only access Modules.

* a Callable, which can be a node for: a method, a static method, a function, a constructor. This
node can no longer have any attributes.

* a Class, which is a node that represents a python class. This node can contain in it: methods - Callable,
static methods - Callable, class method - Callable, slot attributes - StaticAttribute, properties - Property,
enum attributes - EnumAttribute.

* a Module, which represents a python file/module. This node can have as an attribute: global
variables - StaticAttribute, global functions - Callable and classes - Klass.

* a StaticAttribute - represents attribute of a Class or of a Module. This node can no longer have
any more attributes. This can be remotely get and set.

* a Property - represents a @property object of a class. This node can no longer have any more
attributes - a leaf. This can remotely get and set.

* a EnumAttribute - represents the fields generated by an Enum. This node can no longer have any
more attributes - a leaf. This can be remotely get.
"""

# stdlib
from typing import Any as TypeAny
from typing import List as TypeList
from typing import Tuple as TypeTuple
from typing import Union

# syft relative
from . import attribute  # noqa: F401
from . import callable  # noqa: F401
from . import enum  # noqa: F401
from . import globals  # noqa: F401
from . import klass  # noqa: F401
from . import module  # noqa: F401
from . import property  # noqa: F401
from . import static_attr  # noqa: F401


def get_parent(path: str, root: globals.Globals) -> module.Module:
    parent = root
    for step in path.split(".")[:-1]:
        if step in parent.attrs:
            parent = parent.attrs[step]
    return parent


def add_modules(
    ast: globals.Globals,
    modules: Union[TypeList[str], TypeList[TypeTuple[str, TypeAny]]],
) -> None:
    for mod in modules:
        # We also have the reference
        if isinstance(mod, tuple):
            target_module, ref = mod
        else:
            target_module = mod
            ref = None

        parent = get_parent(target_module, ast)
        attr_name = target_module.rsplit(".", 1)[-1]
        parent.add_attr(
            attr_name=attr_name,
            attr=module.Module(
                path_and_name=target_module,
                object_ref=ref,
                return_type_name="",
                client=ast.client,
            ),
        )


def add_classes(
    ast: globals.Globals,
    paths: TypeList[TypeTuple[str, str, TypeAny]],
) -> None:
    for path, return_type, ref in paths:
        parent = get_parent(path, ast)
        attr_name = path.rsplit(".", 1)[-1]
        parent.add_attr(
            attr_name=attr_name,
            attr=klass.Class(
                path_and_name=path,
                object_ref=ref,
                return_type_name=return_type,
                client=ast.client,
            ),
        )


def add_methods(
    ast: globals.Globals,
    paths: TypeList[TypeTuple[str, str]],
) -> None:
    for path, return_type in paths:
        parent = get_parent(path, ast)
        path_list = path.split(".")
        parent.add_path(
            path=path_list,
            index=len(path_list) - 1,
            return_type_name=return_type,
        )
