

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="python" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="python" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>syft.core.workers.base &mdash; PySyft 0.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/PySyft_docs.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> PySyft
          

          
            
            <img src="../../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../notes/example.html">Example Note</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules/modules.html">syft</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules/syft.html">syft package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules/syft.core.html">syft.core package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules/syft.core.frameworks.html">syft.core.frameworks package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules/syft.core.frameworks.tensorflow.html">syft.core.frameworks.tensorflow package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules/syft.core.frameworks.torch.html">syft.core.frameworks.torch package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules/syft.core.workers.html">syft.core.workers package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules/syft.mpc.html">syft.mpc package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules/syft.mpc.interface.html">syft.mpc.interface package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">PySyft</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>syft.core.workers.base</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for syft.core.workers.base</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">syft</span> <span class="k">as</span> <span class="nn">sy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">..frameworks.torch</span> <span class="k">import</span> <span class="n">utils</span> <span class="k">as</span> <span class="n">torch_utils</span>
<span class="kn">from</span> <span class="nn">..frameworks</span> <span class="k">import</span> <span class="n">encode</span>
<span class="kn">from</span> <span class="nn">..frameworks</span> <span class="k">import</span> <span class="n">encode</span> <span class="k">as</span> <span class="n">syft_encoder_router</span>


<div class="viewcode-block" id="BaseWorker"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker">[docs]</a><span class="k">class</span> <span class="nc">BaseWorker</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The BaseWorker class establishes a consistent interface for</span>
<span class="sd">    communicating between different machines</span>
<span class="sd">    about tensors, variables, models, and other network related</span>
<span class="sd">    information. It defines base functionality</span>
<span class="sd">    for storing objects within the worker (or in some cases</span>
<span class="sd">    specifically not storing them), and for keeping</span>
<span class="sd">    track of known workers across a network.</span>

<span class="sd">    This class does NOT include any communication specific functionality</span>
<span class="sd">    such as peer-to-peer protocols, routing, node discovery, or even</span>
<span class="sd">    socket architecture. Only classes that extend the BaseWorker should</span>
<span class="sd">    carry such functionality.</span>

<span class="sd">    :Parameters:</span>

<span class="sd">        * **hook (**:class:`.hooks.BaseHook` **)** This is a reference</span>
<span class="sd">          to the hook object which overloaded the underlying deep</span>
<span class="sd">          learning framework.</span>

<span class="sd">        * **id (int or string, optional)** the integer or string identifier</span>
<span class="sd">          for this node</span>

<span class="sd">        * **is_client_worker (bool, optional)** a boolean which determines</span>
<span class="sd">          whether this worker is associeted with an end user client.</span>
<span class="sd">          If so, it assumes that the client will maintain control over when</span>
<span class="sd">          tensors/variables/models are instantiated or deleted as opposed</span>
<span class="sd">          to handling tensor/variable/model lifecycle internally.</span>

<span class="sd">        * **objects (list of tensors, variables, or models, optional)**</span>
<span class="sd">          When the worker is NOT a client worker, it stores all tensors</span>
<span class="sd">          it receives or creates in this dictionary.</span>
<span class="sd">          The key to each object is it&#39;s id.</span>

<span class="sd">        * **tmp_objects (list of tensors, variables, or models, optional)**</span>
<span class="sd">          When the worker IS a client worker, it stores some tensors</span>
<span class="sd">          temporarily in this _tmp_objects simply to ensure</span>
<span class="sd">          that they do not get deallocated by the Python garbage</span>
<span class="sd">          collector while in the process of being registered.</span>
<span class="sd">          This dictionary can be emptied using the clear_tmp_objects method.</span>

<span class="sd">        * **known_workers (list of **:class:`BaseWorker` ** objects, optional)**</span>
<span class="sd">          This dictionary can include all known workers on a network.</span>
<span class="sd">          Some extensions of BaseWorker will use this</span>
<span class="sd">          list to bootstrap the network.</span>

<span class="sd">        * **verbose (bool, optional)** A flag for whether or not to</span>
<span class="sd">          print events to stdout.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hook</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">is_client_worker</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="p">{},</span>
                 <span class="n">tmp_objects</span><span class="o">=</span><span class="p">{},</span> <span class="n">known_workers</span><span class="o">=</span><span class="p">{},</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">queue_size</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="k">if</span><span class="p">(</span><span class="n">hook</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">hook</span> <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">local_worker</span><span class="o">.</span><span class="n">hook</span>

        <span class="c1"># This is a reference to the hook object which overloaded</span>
        <span class="c1"># the underlying deep learning framework</span>
        <span class="c1"># (at the time of writing this is exclusively TorchHook)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hook</span> <span class="o">=</span> <span class="n">hook</span>

        <span class="c1"># the integer or string identifier for this node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>

        <span class="c1"># a boolean which determines whether this worker is</span>
        <span class="c1"># associated with an end user client. If so, it assumes</span>
        <span class="c1"># that the client will maintain control over when variables</span>
        <span class="c1"># are instantiated or deleted as opposed to</span>
        <span class="c1"># handling tensor/variable/model lifecycle internally.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_client_worker</span> <span class="o">=</span> <span class="n">is_client_worker</span>

        <span class="c1"># The workers permanent registry. When the worker is NOT</span>
        <span class="c1"># a client worker, it stores all tensors it receives</span>
        <span class="c1">#  or creates in this dictionary. The key to each object</span>
        <span class="c1"># is it&#39;s id.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span> <span class="o">=</span> <span class="p">{</span><span class="n">known_worker</span><span class="o">.</span><span class="n">id</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">known_worker</span> <span class="ow">in</span> <span class="n">known_workers</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">objects</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="c1"># Register the pointer by location/id@location</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sy</span><span class="o">.</span><span class="n">_PointerTensor</span><span class="p">):</span>
                <span class="n">v</span><span class="o">.</span><span class="n">register_pointer</span><span class="p">()</span>

        <span class="c1"># The temporary registry. When the worker IS a client</span>
        <span class="c1"># worker, it stores some tensors temporarily in this</span>
        <span class="c1"># _tmp_objects simply to ensure that they do not get</span>
        <span class="c1"># de-allocated by the Python garbage collector while</span>
        <span class="c1"># in the process of being registered. This dictionary</span>
        <span class="c1"># can be emptied using the clear_tmp_objects method.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_objects</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tmp_objects</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_objects</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># This dictionary includes all known workers on a</span>
        <span class="c1"># network. Extensions of BaseWorker will include advanced</span>
        <span class="c1"># functionality for adding to this dictionary (node discovery).</span>
        <span class="c1"># In some cases, one can initialize this with</span>
        <span class="c1"># known workers to help bootstrap the network.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_workers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">known_workers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_known_workers</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_worker</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># A flag for whether or not to print events to stdout.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># A list for storing messages to be sent as well as the max size of the list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message_queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">queue_size</span> <span class="o">=</span> <span class="n">queue_size</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sy</span><span class="p">,</span> <span class="s1">&#39;local_worker&#39;</span><span class="p">):</span>
            <span class="n">sy</span><span class="o">.</span><span class="n">local_worker</span><span class="o">.</span><span class="n">add_worker</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_worker</span><span class="p">(</span><span class="n">sy</span><span class="o">.</span><span class="n">local_worker</span><span class="p">)</span>

<div class="viewcode-block" id="BaseWorker.whoami"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.whoami">[docs]</a>    <span class="k">def</span> <span class="nf">whoami</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns metadata information about the worker. This function returns the default</span>
<span class="sd">        which is the id and type of the current worker. Other worker types can extend this</span>
<span class="sd">        function with additional metadata such as network information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">({</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)})</span></div>

    <span class="k">def</span> <span class="nf">_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries all local tensors which have string ids, returning the tensors which match the query. The query is</span>
<span class="sd">        composed of one or more substrings which all be contained within a tensor&#39;s ID in order for it to be a match.</span>
<span class="sd">        :param query: either a string or a list of strings</span>
<span class="sd">        :return: a list of tensors</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">query</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">query</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="n">failed</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">query</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">constraint</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">id</span><span class="p">:</span>
                        <span class="n">failed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">failed</span><span class="p">):</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="BaseWorker.search"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.search">[docs]</a>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="s2">&quot;#boston&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries all local tensors which have string ids, returning the tensors which match the query. The query is</span>
<span class="sd">        composed of one or more substrings which all be contained within a tensor&#39;s ID in order for it to be a match.</span>
<span class="sd">        :param query: either a string or a list of strings</span>
<span class="sd">        :return: a list of tensors</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_search</span><span class="p">(</span><span class="n">query</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWorker.send_msg"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.send_msg">[docs]</a>    <span class="k">def</span> <span class="nf">send_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">message_type</span><span class="p">,</span> <span class="n">recipient</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sends a string message to another worker with message_type information</span>
<span class="sd">        indicating how the message should be processed.</span>

<span class="sd">        :Parameters:</span>

<span class="sd">        * **recipient (** :class:`VirtualWorker` **)** the worker being sent a message.</span>

<span class="sd">        * **message (string)** the message being sent</span>

<span class="sd">        * **message_type (string)** the type of message being sent. This affects how</span>
<span class="sd">          the message is processed by the recipient. The types of message are described</span>
<span class="sd">          in :func:`receive_msg`.</span>

<span class="sd">        * **out (object)** the response from the message being sent. This can be a variety</span>
<span class="sd">          of object types. However, the object is typically only used during testing or</span>
<span class="sd">          local development with :class:`VirtualWorker` workers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">message_wrapper</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;message&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">message</span>
        <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">message_type</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">message_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">message_wrapper</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_size</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue_size</span><span class="p">:</span>
                <span class="n">message_wrapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compile_composite_message</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="n">message_wrapper_json</span> <span class="o">=</span> <span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">message_wrapper</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">message_queue</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_msg</span><span class="p">(</span><span class="n">message_wrapper_json</span><span class="p">,</span> <span class="n">recipient</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWorker.compile_composite_message"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.compile_composite_message">[docs]</a>    <span class="k">def</span> <span class="nf">compile_composite_message</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a composite message in a dictionary from the message queue.</span>
<span class="sd">        Evenatually will take a recipient id.</span>

<span class="sd">        * **out (dict)** dictionary containing the message queue compiled</span>
<span class="sd">        as a composite message</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">message_wrapper</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;message&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">message_number</span><span class="p">:</span> <span class="n">message</span> <span class="k">for</span> <span class="n">message_number</span><span class="p">,</span> <span class="n">message</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message_queue</span><span class="p">)}</span>
        <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;composite&#39;</span>

        <span class="k">return</span> <span class="n">message_wrapper</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_send_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message_wrapper_json_binary</span><span class="p">,</span> <span class="n">recipient</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sends a string message to another worker with message_type information</span>
<span class="sd">        indicating how the message should be processed.</span>

<span class="sd">        :Parameters:</span>

<span class="sd">        * **recipient (** :class:`VirtualWorker` **)** the worker being sent a message.</span>

<span class="sd">        * **message_wrapper_json_binary (binary)** the message being sent encoded in binary</span>

<span class="sd">        * **out (object)** the response from the message being sent. This can be a variety</span>
<span class="sd">          of object types. However, the object is typically only used during testing or</span>
<span class="sd">          local development with :class:`VirtualWorker` workers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sy</span><span class="o">.</span><span class="n">_LocalTensor</span><span class="p">()</span>

<div class="viewcode-block" id="BaseWorker.receive_msg"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.receive_msg">[docs]</a>    <span class="k">def</span> <span class="nf">receive_msg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message_wrapper_json</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Receives an message from a worker and then executes its contents appropriately.</span>
<span class="sd">        The message is encoded as a binary blob.</span>

<span class="sd">        * **message (binary)** the message being sent</span>

<span class="sd">        * **out (object)** the response. This can be a variety</span>
<span class="sd">          of object types. However, the object is typically only used during testing or</span>
<span class="sd">          local development with :class:`VirtualWorker` workers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">message_wrapper</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">message_wrapper_json</span><span class="p">,</span> <span class="n">worker</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">response</span><span class="p">,</span> <span class="n">private</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_message_type</span><span class="p">(</span><span class="n">message_wrapper</span><span class="p">)</span>

        <span class="n">response</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">retrieve_pointers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">private_local</span><span class="o">=</span><span class="n">private</span><span class="p">)</span>

        <span class="n">response</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">response</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">response</span></div>

<div class="viewcode-block" id="BaseWorker.process_message_type"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.process_message_type">[docs]</a>    <span class="k">def</span> <span class="nf">process_message_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message_wrapper</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method takes a message wrapper and attempts to process</span>
<span class="sd">        it agaist known processing methods. If the method is a composite</span>
<span class="sd">        message, it unroles applies recursively</span>

<span class="sd">        * **message_wrapper (dict)** Dictionary containing the message</span>
<span class="sd">          and meta information</span>

<span class="sd">        * **out (object, bool)** the response. This can be a variety</span>
<span class="sd">          of object types. However, the object is typically only</span>
<span class="sd">          used during testing or local development with</span>
<span class="sd">          :class:`VirtualWorker` workers. The bool specifies if the</span>
<span class="sd">          response is private or not (private: we don&#39;t encode the data</span>
<span class="sd">          but juts info on the tensor; not private: we transmit data to be</span>
<span class="sd">          acquired by the receiver)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;message&#39;</span><span class="p">]</span>

        <span class="c1"># Receiving an object from another worker</span>
        <span class="k">if</span> <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;obj&#39;</span><span class="p">:</span>

            <span class="nb">object</span> <span class="o">=</span> <span class="n">message</span>

            <span class="c1"># if object is a numpy array</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="s2">&quot;do nothing&quot;</span>

            <span class="c1"># if object is a Torch object - pre-process it for registration</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">torch_utils</span><span class="o">.</span><span class="n">fix_chain_ends</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">torch_utils</span><span class="o">.</span><span class="n">assert_is_chain_well_formed</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">{},</span> <span class="kc">False</span>


        <span class="c1">#  Receiving a request for an object from another worker</span>
        <span class="k">elif</span> <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;req_obj&#39;</span><span class="p">:</span>
            <span class="c1"># Because it was pointed at, it&#39;s the first syft_object of the chain,</span>
            <span class="c1"># so its parent is the tensorvar</span>
            <span class="nb">object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_obj</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="c1"># if object being returned is a numpy array</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="s2">&quot;&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">de_register</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">object</span><span class="p">,</span> <span class="kc">False</span>

            <span class="c1"># object is a pytorch array</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tensorvar</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">parent</span>
                <span class="k">if</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">is_variable</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="n">torch_type</span><span class="p">):</span>
                    <span class="n">syft_data_object</span> <span class="o">=</span> <span class="n">tensorvar</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">child</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">de_register</span><span class="p">(</span><span class="n">syft_data_object</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">tensorvar</span><span class="o">.</span><span class="n">grad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">syft_grad_object</span> <span class="o">=</span> <span class="n">tensorvar</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">child</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">de_register</span><span class="p">(</span><span class="n">syft_grad_object</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">de_register</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">tensorvar</span><span class="p">,</span> <span class="kc">False</span>

        <span class="c1">#  A torch command from another worker involving one or more tensors</span>
        <span class="c1">#  hosted locally</span>
        <span class="k">elif</span> <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;torch_cmd&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_torch_command</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="kc">True</span>  <span class="c1"># Result is private</span>

        <span class="k">elif</span> <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;numpy_cmd&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_numpy_command</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="kc">True</span>  <span class="c1"># Result is private</span>

        <span class="c1"># A composite command. Must be unrolled</span>
        <span class="k">elif</span> <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;composite&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Composite command not handled at the moment&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;query&#39;</span><span class="p">:</span>

            <span class="n">tensors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

            <span class="n">pointers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">tensor</span> <span class="ow">in</span> <span class="n">tensors</span><span class="p">:</span>
                <span class="n">ptr</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">create_pointer</span><span class="p">()</span>
                <span class="n">encoding</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">private_local</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">retrieve_pointers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">pointers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">pointers</span><span class="p">,</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="s2">&quot;Unrecognized message type:&quot;</span> <span class="o">+</span> <span class="n">message_wrapper</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;&lt;&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot; id:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;&gt;&quot;</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

<div class="viewcode-block" id="BaseWorker.add_worker"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.add_worker">[docs]</a>    <span class="k">def</span> <span class="nf">add_worker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;add_worker(worker) -&gt; None</span>
<span class="sd">        This method adds a worker to the list of _known_workers</span>
<span class="sd">        internal to the BaseWorker. It endows this class with</span>
<span class="sd">        the ability to communicate with the remote worker being</span>
<span class="sd">        added, such as sending and receiving objects, commands,</span>
<span class="sd">        or information about the network.</span>

<span class="sd">        :Parameters:</span>

<span class="sd">        * **worker (**:class:`BaseWorker` **)** This is an object</span>
<span class="sd">          pointer to a remote worker, which must have a unique id.</span>

<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; import syft as sy</span>
<span class="sd">        &gt;&gt;&gt; hook = sy.TorchHook(verbose=False)</span>
<span class="sd">        &gt;&gt;&gt; me = hook.local_worker</span>
<span class="sd">        &gt;&gt;&gt; bob = sy.VirtualWorker(id=&quot;bob&quot;,hook=hook, is_client_worker=False)</span>
<span class="sd">        &gt;&gt;&gt; me.add_workers([bob])</span>
<span class="sd">        &gt;&gt;&gt; x = sy.FloatTensor([1,2,3,4,5])</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">         1</span>
<span class="sd">         2</span>
<span class="sd">         3</span>
<span class="sd">         4</span>
<span class="sd">         5</span>
<span class="sd">        [syft.core.frameworks.torch.tensor.FloatTensor of size 5]</span>
<span class="sd">        &gt;&gt;&gt; x.send(bob)</span>
<span class="sd">        FloatTensor[_PointerTensor - id:9121428371 owner:0 loc:bob id@loc:47416674672]</span>
<span class="sd">        &gt;&gt;&gt; x.get()</span>
<span class="sd">         1</span>
<span class="sd">         2</span>
<span class="sd">         3</span>
<span class="sd">         4</span>
<span class="sd">         5</span>
<span class="sd">        [syft.core.frameworks.torch.tensor.FloatTensor of size 5]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_workers</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Worker ID &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; taken. Have I seen this worker before?&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Replacing it anyways... this could cause unexpected behavior...&quot;</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_workers</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Worker &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">worker</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; already exists. Replacing old worker which could cause&quot;</span><span class="o">+</span>
                         <span class="s2">&quot;unexpected behavior&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_known_workers</span><span class="p">[</span><span class="n">worker</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span></div>

<div class="viewcode-block" id="BaseWorker.add_workers"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.add_workers">[docs]</a>    <span class="k">def</span> <span class="nf">add_workers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">workers</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">worker</span> <span class="ow">in</span> <span class="n">workers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_worker</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWorker.get_worker"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.get_worker">[docs]</a>    <span class="k">def</span> <span class="nf">get_worker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_or_worker</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get_worker(self, id_or_worker) -&gt; BaseWorker</span>
<span class="sd">        If you pass in an ID, it will attempt to find the worker</span>
<span class="sd">        object (pointer) withins self._known_workers. If you</span>
<span class="sd">        instead pass in a pointer itself, it will save that as a</span>
<span class="sd">        known_worker if it does not exist as one. This method is primarily useful</span>
<span class="sd">        becuase often tensors have to store only the ID to a</span>
<span class="sd">        foreign worker which may or may not be known</span>
<span class="sd">        by the worker that is deserializing it at the time</span>
<span class="sd">        of deserialization. This method allows for resolution of</span>
<span class="sd">        worker ids to workers to happen automatically while also</span>
<span class="sd">        making the current worker aware of new ones when discovered</span>
<span class="sd">        through other processes.</span>


<span class="sd">        :Parameters:</span>

<span class="sd">        * **id_or_worker (string or int or** :class:`BaseWorker` **)**</span>
<span class="sd">          This is either the id of the object to be returned or the object itself.</span>

<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; import syft as sy</span>
<span class="sd">        &gt;&gt;&gt; hook = sy.TorchHook(verbose=False)</span>
<span class="sd">        &gt;&gt;&gt; me = hook.local_worker</span>
<span class="sd">        &gt;&gt;&gt; bob = sy.VirtualWorker(id=&quot;bob&quot;,hook=hook, is_client_worker=False)</span>
<span class="sd">        &gt;&gt;&gt; me.add_workers([bob])</span>
<span class="sd">        &gt;&gt;&gt; bob</span>
<span class="sd">        &lt;syft.core.workers.virtual.VirtualWorker id:bob&gt;</span>
<span class="sd">        &gt;&gt;&gt; # we can get the worker using it&#39;s id (1)</span>
<span class="sd">        &gt;&gt;&gt; me.get_worker(&#39;bob&#39;)</span>
<span class="sd">        &lt;syft.core.workers.virtual.VirtualWorker id:bob&gt;</span>
<span class="sd">        &gt;&gt;&gt; # or we can get the worker by passing in the worker</span>
<span class="sd">        &gt;&gt;&gt; me.get_worker(bob)</span>
<span class="sd">        &lt;syft.core.workers.virtual.VirtualWorker id:bob&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">id_or_worker</span><span class="p">),</span> <span class="n">BaseWorker</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">id_or_worker</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_workers</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_worker</span><span class="p">(</span><span class="n">id_or_worker</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_workers</span><span class="p">[</span><span class="n">id_or_worker</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">id_or_worker</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_workers</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_known_workers</span><span class="p">[</span><span class="n">id_or_worker</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Worker&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="s1">&#39;couldnt recognize worker&#39;</span><span class="p">,</span> <span class="n">id_or_worker</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">id_or_worker</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">id_or_worker</span></div>

<div class="viewcode-block" id="BaseWorker.get_obj"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.get_obj">[docs]</a>    <span class="k">def</span> <span class="nf">get_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remote_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;get_obj(remote_key) -&gt; a torch object</span>
<span class="sd">        This method fetches a tensor from the worker&#39;s internal</span>
<span class="sd">        registry of tensors using its id. Note that this</span>
<span class="sd">        will not work on client worker because they do not</span>
<span class="sd">        store objects internally. However, it can be used on</span>
<span class="sd">        remote workers, including remote :class:`VirtualWorker`</span>
<span class="sd">        objects, as pictured below in the example.</span>

<span class="sd">        :Parameters:</span>

<span class="sd">        * **remote_key (string or int)** This is the id of</span>
<span class="sd">          the object to be returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">remote_key</span><span class="p">]</span>
        <span class="c1"># Fix ownership if the obj has been modified out of control (like with backward())</span>
        <span class="n">torch_utils</span><span class="o">.</span><span class="n">enforce_owner</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="BaseWorker.set_obj"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.set_obj">[docs]</a>    <span class="k">def</span> <span class="nf">set_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remote_key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method adds an object (such as a tensor) to one of</span>
<span class="sd">        the internal object registries. The main registry</span>
<span class="sd">        holds objects for a long period of time (until they are</span>
<span class="sd">        explicitly deleted) while the temporary registory</span>
<span class="sd">        will delete all object references contained therein when</span>
<span class="sd">        the cleanup method is called (self._clear_tmp_objects).</span>


<span class="sd">        The reason we have a temporary registry for clijen workers</span>
<span class="sd">        (instead of putting everything in the permanent one) is</span>
<span class="sd">        because when the client creates a reference to an object</span>
<span class="sd">        (x = torch.zeros(10)), we want to ensure that the client</span>
<span class="sd">        contains the only pointer to that object so that when the</span>
<span class="sd">        client deletes the object that __del__ gets called. If,</span>
<span class="sd">        however, the object was also being stored in the permanent</span>
<span class="sd">        registry (self._objects), then when the variable went out</span>
<span class="sd">        of scope on the client, the python garbage collector wouldn&#39;t</span>
<span class="sd">        call __del__ because the internal registry would</span>
<span class="sd">        still have a reference to it. So, we use the temporary registry</span>
<span class="sd">        during the construction of the object but then</span>
<span class="sd">        delete all references to the object (other than the client&#39;s)</span>
<span class="sd">        once object construction and (recursive) registration</span>
<span class="sd">        is complete.</span>

<span class="sd">        When the worker is not a client worker (self._is_client_worker==False),</span>
<span class="sd">        this method just saves an object into the permanent registry,</span>
<span class="sd">        where it remains until it is explicitly deleted using self._rm_obj.</span>

<span class="sd">        :Parameters:</span>

<span class="sd">        * **remote_key (int)** This is an object id to an object to be</span>
<span class="sd">          stored in memory.</span>

<span class="sd">        * **value (torch.Tensor or torch.autograd.Variable) ** the</span>
<span class="sd">          object to be stored in memory.</span>

<span class="sd">        * **force (bool, optional)** if set to True, this will force the</span>
<span class="sd">          object to be stored in permenent memory, even if</span>
<span class="sd">          the current worker is a client worker (Default: False).</span>

<span class="sd">        * **tmp (bool, optional)** if set to True, this will allow an object</span>
<span class="sd">          to be stored in temporary memory if and only if</span>
<span class="sd">          the worker is also a client worker. If set to false, the object</span>
<span class="sd">          will not be stored in temporary memory, even if the</span>
<span class="sd">          worker is a client worker.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tmp</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_client_worker</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_objects</span><span class="p">[</span><span class="n">remote_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_client_worker</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">remote_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="BaseWorker.rm_obj"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.rm_obj">[docs]</a>    <span class="k">def</span> <span class="nf">rm_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remote_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method removes an object from the permament object registory</span>
<span class="sd">        if it exists.</span>

<span class="sd">        :parameters:</span>

<span class="sd">        * **remote_key(int or string)** the id of the object to be removed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">remote_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">remote_key</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">sy</span><span class="o">.</span><span class="n">_PointerTensor</span><span class="p">):</span>
                <span class="n">pointer</span> <span class="o">=</span> <span class="n">obj</span>
                <span class="n">location</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.</span><span class="n">location</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pointer</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="k">else</span> <span class="n">pointer</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">id</span>
                <span class="n">id_at_location</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">.</span><span class="n">id_at_location</span>
                <span class="k">if</span> <span class="n">location</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">id_at_location</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span><span class="p">[</span><span class="n">location</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span><span class="p">[</span><span class="n">location</span><span class="p">][</span><span class="n">id_at_location</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">remote_key</span><span class="p">]</span></div>



    <span class="k">def</span> <span class="nf">_clear_tmp_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method releases all objects from the temporary registry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_objects</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="BaseWorker.de_register"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.de_register">[docs]</a>    <span class="k">def</span> <span class="nf">de_register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Un-register an object and its attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">is_syft_tensor</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rm_obj</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">de_register</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">is_variable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">de_register</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">de_register</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
        <span class="c1"># Case of a iter type non json serializable</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">,</span> <span class="nb">range</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">de_register</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="s2">&quot;do nothing&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rm_obj</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The type&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="s1">&#39;is not supported at the moment&#39;</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BaseWorker.de_register_object"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.de_register_object">[docs]</a>    <span class="k">def</span> <span class="nf">de_register_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">_recurse_torch_objs</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unregisters an object and removes attributes which are indicative</span>
<span class="sd">        of registration. Note that the way in which attributes are deleted</span>
<span class="sd">        has been informed by this StackOverflow post: https://goo.gl/CBEKLK</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">is_torch_tensor</span> <span class="o">=</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_torch_tensor</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rm_obj</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">id</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;owner&#39;</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">owner</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;child&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">child</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_torch_tensor</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_recurse_torch_objs</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">de_register_object</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">child</span><span class="p">,</span>
                                                <span class="n">_recurse_torch_objs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">de_register_object</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">child</span><span class="p">,</span>
                                            <span class="n">_recurse_torch_objs</span><span class="o">=</span><span class="n">_recurse_torch_objs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_torch_tensor</span><span class="p">:</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;child&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWorker.register"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register an object with SyftTensors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">is_syft_tensor</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="n">syft_obj</span> <span class="o">=</span> <span class="n">result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_object</span><span class="p">(</span><span class="n">syft_obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="n">tensor</span> <span class="o">=</span> <span class="n">result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_object</span><span class="p">(</span><span class="n">tensor</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">is_variable</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="n">variable</span> <span class="o">=</span> <span class="n">result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="s1">&#39;grad&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">variable</span><span class="o">.</span><span class="n">grad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">variable</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
        <span class="c1"># Case of a iter type non json serializable</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">,</span> <span class="nb">range</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="s2">&quot;do nothing&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_object</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;The type&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="s1">&#39;is not supported at the moment&#39;</span><span class="p">)</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="BaseWorker.register_object"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.register_object">[docs]</a>    <span class="k">def</span> <span class="nf">register_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Registers an object with the current worker node. Selects an</span>
<span class="sd">        id for the object, assigns a list of owners,</span>
<span class="sd">        and establishes whether it&#39;s a pointer or not. This method</span>
<span class="sd">        is generally not used by the client and is</span>
<span class="sd">        instead used by internal processes (hooks and workers).</span>

<span class="sd">        :Parameters:</span>

<span class="sd">        * **obj (a torch.Tensor or torch.autograd.Variable)** a Torch</span>
<span class="sd">          instance, e.g. Tensor or Variable to be registered</span>

<span class="sd">        * **force_attach_to_worker (bool)** if set to True, it will</span>
<span class="sd">          force the object to be stored in the worker&#39;s permanent registry</span>

<span class="sd">        * **temporary (bool)** If set to True, it will store the object</span>
<span class="sd">          in the worker&#39;s temporary registry.</span>

<span class="sd">        :kwargs:</span>

<span class="sd">        * **id (int or string)** random integer between 0 and 1e10 or</span>
<span class="sd">          string uniquely identifying the object.</span>

<span class="sd">        * **owners (list of ** :class:`BaseWorker` objects ** or ids)**</span>
<span class="sd">          owner(s) of the object</span>

<span class="sd">        * **is_pointer (bool, optional)** Whether or not the tensor being</span>
<span class="sd">          registered contains the data locally or is instead a pointer to</span>
<span class="sd">          a tensor that lives on a different worker.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if not torch_utils.is_syft_tensor(obj):</span>
            <span class="c1"># raise TypeError(&quot;Can&#39;t register a non-SyftTensor&quot;)</span>

        <span class="k">if</span> <span class="nb">id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>

        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">owner</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_obj</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Registering a pointer on non-owned syftTensor.&quot;</span><span class="p">)</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">create_pointer</span><span class="p">()</span>
            <span class="n">pointer</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_obj</span><span class="p">(</span><span class="n">pointer</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">pointer</span><span class="p">)</span></div>

        <span class="c1"># DO NOT DELETE THIS TRY/CATCH UNLESS YOU KNOW WHAT YOU&#39;RE DOING</span>
        <span class="c1"># PyTorch tensors wrapped invariables (if my_var.data) are python</span>
        <span class="c1"># objects that get deleted and re-created randomly according to</span>
        <span class="c1"># the whims of the PyTorch wizards. Thus, our attributes were getting</span>
        <span class="c1"># deleted with them (because they are not present in the underlying</span>
        <span class="c1"># C++ code.) Thus, so that these python objects do NOT get garbage</span>
        <span class="c1"># collected, we&#39;re creating a secondary reference to them from the</span>
        <span class="c1"># parent Variable object (which we have been told is stable). This</span>
        <span class="c1"># is experimental functionality but seems to solve the symptoms we</span>
        <span class="c1"># were previously experiencing.</span>
        <span class="c1"># try:</span>
        <span class="c1">#    obj.data_backup = obj.data</span>
        <span class="c1"># except:</span>
        <span class="c1">#    &quot;&quot;</span>

<div class="viewcode-block" id="BaseWorker.process_numpy_command"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.process_numpy_command">[docs]</a>    <span class="k">def</span> <span class="nf">process_numpy_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;process_command(self, command_msg) -&gt; (command output, list of owners)</span>
<span class="sd">        Process a command message from a client worker. Returns the</span>
<span class="sd">        result of the computation and a list of the result&#39;s owners.</span>

<span class="sd">        :Parameters:</span>

<span class="sd">        * **command_msg (dict)** The dictionary containing a</span>
<span class="sd">          command from another worker.</span>

<span class="sd">        * **out (command output, list of** :class:`BaseWorker`</span>
<span class="sd">          ids/objects **)** This executes the command</span>
<span class="sd">          and returns its output along with a list of</span>
<span class="sd">          the owners of the tensors involved.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># torch_utils.assert_has_only_torch_tensorvars(command_msg)</span>

        <span class="n">attr</span> <span class="o">=</span> <span class="n">command_msg</span><span class="p">[</span><span class="s1">&#39;command&#39;</span><span class="p">]</span>
        <span class="n">has_self</span> <span class="o">=</span> <span class="n">command_msg</span><span class="p">[</span><span class="s1">&#39;has_self&#39;</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">command_msg</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">command_msg</span><span class="p">[</span><span class="s1">&#39;kwargs&#39;</span><span class="p">]</span>
        <span class="n">self_</span> <span class="o">=</span> <span class="n">command_msg</span><span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">has_self</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_numpy_call</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">self_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_execute_numpy_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">self_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transmit the call to the appropriate TensorType for handling</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Distinguish between a command with torch tensors (like when called by the client,</span>
        <span class="c1"># or received from another worker), and a command with syft tensor, which can occur</span>
        <span class="c1"># when a function is overloaded by a SyftTensor (for instance _PlusIsMinusTensor</span>
        <span class="c1"># overloads add and replace it by sub)</span>
        <span class="c1"># try:</span>
        <span class="c1">#     torch_utils.assert_has_only_torch_tensorvars((args, kwargs))</span>
        <span class="c1">#     is_torch_command = True</span>
        <span class="c1"># except AssertionError:</span>
        <span class="n">is_torch_command</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">has_self</span> <span class="o">=</span> <span class="n">self_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># if has_self:</span>
        <span class="c1">#     command = torch._command_guard(attr, torch.tensorvar_methods)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     command = torch._command_guard(attr, torch.torch_modules)</span>
        <span class="n">command</span> <span class="o">=</span> <span class="n">attr</span>

        <span class="n">raw_command</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;command&#39;</span><span class="p">:</span> <span class="n">command</span><span class="p">,</span>
            <span class="s1">&#39;has_self&#39;</span><span class="p">:</span> <span class="n">has_self</span><span class="p">,</span>
            <span class="s1">&#39;args&#39;</span><span class="p">:</span> <span class="n">args</span><span class="p">,</span>
            <span class="s1">&#39;kwargs&#39;</span><span class="p">:</span> <span class="n">kwargs</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">has_self</span><span class="p">:</span>
            <span class="n">raw_command</span><span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">self_</span>

        <span class="c1"># if is_torch_command:</span>
        <span class="c1">#     # Unwrap the torch wrapper</span>
        <span class="c1">#     syft_command, child_type = torch_utils.prepare_child_command(</span>
        <span class="c1">#         raw_command, replace_tensorvar_with_child=True)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     # Get the next syft class</span>
        <span class="c1">#     # The actual syft class is the one which redirected (see the  _PlusIsMinus ex.)</span>
        <span class="c1">#     syft_command, child_type = torch_utils.prepare_child_command(</span>
        <span class="c1">#         raw_command, replace_tensorvar_with_child=True)</span>
        <span class="c1">#</span>
        <span class="c1">#     torch_utils.assert_has_only_syft_tensors(syft_command)</span>

        <span class="c1"># Note: because we have pb of registration of tensors with the right worker,</span>
        <span class="c1"># and because having Virtual workers creates even more ambiguity, we specify the worker</span>
        <span class="c1"># performing the operation</span>
        <span class="c1"># torch_utils.enforce_owner(raw_command, self)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">sy</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">handle_call</span><span class="p">(</span><span class="n">raw_command</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">torch_utils</span><span class="o">.</span><span class="n">enforce_owner</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_torch_command</span><span class="p">:</span>
            <span class="c1"># Wrap the result</span>
            <span class="k">if</span> <span class="n">has_self</span> <span class="ow">and</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_in_place_method</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">wrap_command_with</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">raw_command</span><span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">wrap_command</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="BaseWorker.process_torch_command"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.process_torch_command">[docs]</a>    <span class="k">def</span> <span class="nf">process_torch_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command_msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;process_command(self, command_msg) -&gt; (command output, list of owners)</span>
<span class="sd">        Process a command message from a client worker. Returns the</span>
<span class="sd">        result of the computation and a list of the result&#39;s owners.</span>

<span class="sd">        :Parameters:</span>

<span class="sd">        * **command_msg (dict)** The dictionary containing a</span>
<span class="sd">          command from another worker.</span>

<span class="sd">        * **out (command output, list of** :class:`BaseWorker`</span>
<span class="sd">          ids/objects **)** This executes the command</span>
<span class="sd">          and returns its output along with a list of</span>
<span class="sd">          the owners of the tensors involved.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">torch_utils</span><span class="o">.</span><span class="n">assert_has_only_torch_tensorvars</span><span class="p">(</span><span class="n">command_msg</span><span class="p">)</span>

        <span class="n">attr</span> <span class="o">=</span> <span class="n">command_msg</span><span class="p">[</span><span class="s1">&#39;command&#39;</span><span class="p">]</span>
        <span class="n">has_self</span> <span class="o">=</span> <span class="n">command_msg</span><span class="p">[</span><span class="s1">&#39;has_self&#39;</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">command_msg</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">command_msg</span><span class="p">[</span><span class="s1">&#39;kwargs&#39;</span><span class="p">]</span>
        <span class="n">self_</span> <span class="o">=</span> <span class="n">command_msg</span><span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">has_self</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_call</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">self_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_execute_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">self_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transmit the call to the appropriate TensorType for handling</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if this is none - then it means that self_ is not a torch wrapper</span>
        <span class="c1"># and we need to execute one level higher</span>
        <span class="k">if</span><span class="p">(</span><span class="n">self_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">self_</span><span class="o">.</span><span class="n">child</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">new_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">torch_utils</span><span class="o">.</span><span class="n">is_syft_tensor</span><span class="p">(</span><span class="n">arg</span><span class="p">)):</span>
                        <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_call</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">self_</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span> <span class="o">*</span><span class="n">new_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Distinguish between a command with torch tensors (like when called by the client,</span>
        <span class="c1"># or received from another worker), and a command with syft tensor, which can occur</span>
        <span class="c1"># when a function is overloaded by a SyftTensor (for instance _PlusIsMinusTensor</span>
        <span class="c1"># overloads add and replace it by sub)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">torch_utils</span><span class="o">.</span><span class="n">assert_has_only_torch_tensorvars</span><span class="p">((</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
            <span class="n">is_torch_command</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="n">is_torch_command</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">has_self</span> <span class="o">=</span> <span class="n">self_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">has_self</span><span class="p">:</span>
            <span class="n">command</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">_command_guard</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensorvar_methods</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">command</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">_command_guard</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">torch_modules</span><span class="p">)</span>

        <span class="n">raw_command</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;command&#39;</span><span class="p">:</span> <span class="n">command</span><span class="p">,</span>
            <span class="s1">&#39;has_self&#39;</span><span class="p">:</span> <span class="n">has_self</span><span class="p">,</span>
            <span class="s1">&#39;args&#39;</span><span class="p">:</span> <span class="n">args</span><span class="p">,</span>
            <span class="s1">&#39;kwargs&#39;</span><span class="p">:</span> <span class="n">kwargs</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">has_self</span><span class="p">:</span>
            <span class="n">raw_command</span><span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">self_</span>
        <span class="k">if</span> <span class="n">is_torch_command</span><span class="p">:</span>
            <span class="c1"># Unwrap the torch wrapper</span>
            <span class="n">syft_command</span><span class="p">,</span> <span class="n">child_type</span> <span class="o">=</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">prepare_child_command</span><span class="p">(</span>
                <span class="n">raw_command</span><span class="p">,</span> <span class="n">replace_tensorvar_with_child</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get the next syft class</span>
            <span class="c1"># The actual syft class is the one which redirected (see the  _PlusIsMinus ex.)</span>
            <span class="n">syft_command</span><span class="p">,</span> <span class="n">child_type</span> <span class="o">=</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">prepare_child_command</span><span class="p">(</span>
                <span class="n">raw_command</span><span class="p">,</span> <span class="n">replace_tensorvar_with_child</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">torch_utils</span><span class="o">.</span><span class="n">assert_has_only_syft_tensors</span><span class="p">(</span><span class="n">syft_command</span><span class="p">)</span>

        <span class="c1"># Note: because we have pb of registration of tensors with the right worker,</span>
        <span class="c1"># and because having Virtual workers creates even more ambiguity, we specify the worker</span>
        <span class="c1"># performing the operation</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">child_type</span><span class="o">.</span><span class="n">handle_call</span><span class="p">(</span><span class="n">syft_command</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">torch_utils</span><span class="o">.</span><span class="n">enforce_owner</span><span class="p">((</span><span class="n">raw_command</span><span class="p">,</span> <span class="n">result</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_torch_command</span><span class="p">:</span>
            <span class="c1"># Wrap the result</span>
            <span class="k">if</span> <span class="n">has_self</span> <span class="ow">and</span> <span class="n">utils</span><span class="o">.</span><span class="n">is_in_place_method</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
                <span class="n">wrapper</span> <span class="o">=</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">wrap_command_with</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">raw_command</span><span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">wrapper</span> <span class="o">=</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">wrap_command</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">wrapper</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We don&#39;t need to wrap</span>
            <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="BaseWorker.send_obj"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.send_obj">[docs]</a>    <span class="k">def</span> <span class="nf">send_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="n">new_id</span><span class="p">,</span> <span class="n">recipient</span><span class="p">,</span> <span class="n">new_data_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_grad_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new_grad_data_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;send_obj(self, obj, new_id, recipient, new_data_id=None) -&gt; obj</span>
<span class="sd">        Sends an object to another :class:`VirtualWorker` and removes it</span>
<span class="sd">        from the local worker.</span>

<span class="sd">        :Parameters:</span>
<span class="sd">        * **object (object)** a python object to be sent</span>
<span class="sd">        * **new_id (int)** the id where the object should be stored</span>
<span class="sd">        * **recipient (** :class:`VirtualWorker` **)** the worker object to send the message to.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if the object is a torch object, run some special checks, otherwise just set the ID</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;child&#39;</span><span class="p">)):</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">new_id</span>

            <span class="k">if</span> <span class="n">torch_utils</span><span class="o">.</span><span class="n">is_variable</span><span class="p">(</span><span class="nb">object</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">torch_type</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">new_data_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_grad_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">new_grad_data_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="s1">&#39;Please provide the new_data_id, new_grad_id, and new_grad_data_id args, to be able to point to&#39;</span> <span class="o">+</span>
                        <span class="s1">&#39;Var.data, .grad&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pointer_to</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="n">new_data_id</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s1">&#39;You already point at &#39;</span><span class="p">,</span> <span class="n">recipient</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">new_id</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">new_id</span> <span class="o">!=</span> <span class="n">new_data_id</span><span class="p">,</span> \
                    <span class="s2">&quot;You can&#39;t have the same id vor the variable and its data.&quot;</span>
                <span class="k">assert</span> <span class="n">new_id</span> <span class="o">!=</span> <span class="n">new_grad_id</span><span class="p">,</span> \
                    <span class="s2">&quot;You can&#39;t have the same id vor the variable and its grad.&quot;</span>
                <span class="k">assert</span> <span class="n">new_id</span> <span class="o">!=</span> <span class="n">new_grad_data_id</span>

                <span class="k">assert</span> <span class="n">new_data_id</span> <span class="o">!=</span> <span class="n">new_grad_id</span>

                <span class="k">assert</span> <span class="n">new_data_id</span> <span class="o">!=</span> <span class="n">new_grad_data_id</span>

                <span class="k">assert</span> <span class="n">new_grad_id</span> <span class="o">!=</span> <span class="n">new_grad_data_id</span>

                <span class="nb">object</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">new_data_id</span>

                <span class="k">if</span> <span class="nb">object</span><span class="o">.</span><span class="n">grad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">object</span><span class="o">.</span><span class="n">init_grad_</span><span class="p">()</span>

                <span class="nb">object</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">new_grad_id</span>

                <span class="nb">object</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">child</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">new_grad_data_id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">new_id</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pointer_to</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="n">new_id</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s1">&#39;You already point at &#39;</span><span class="p">,</span> <span class="n">recipient</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">new_id</span><span class="p">)</span>


        <span class="nb">object</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">retrieve_pointers</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">private_local</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># We don&#39;t need any response to proceed to registration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
                      <span class="n">message_type</span><span class="o">=</span><span class="s1">&#39;obj&#39;</span><span class="p">,</span>
                      <span class="n">recipient</span><span class="o">=</span><span class="n">recipient</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWorker.send_torch_command"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.send_torch_command">[docs]</a>    <span class="k">def</span> <span class="nf">send_torch_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recipient</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;send_torch_command(self, recipient, message) -&gt; object</span>

<span class="sd">        This method sends a message to another worker in a way that hangs... waiting until the</span>
<span class="sd">        worker responds with a message. It then processes the response using a response handler</span>

<span class="sd">        :Parameters:</span>

<span class="sd">        * **recipient (** :class:`VirtualWorker` **)** the worker being sent a message.</span>

<span class="sd">        * **message (string)** the message being sent</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">framework</span><span class="o">=</span><span class="s2">&quot;torch&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BaseWorker.send_command"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.send_command">[docs]</a>    <span class="k">def</span> <span class="nf">send_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recipient</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">framework</span><span class="o">=</span><span class="s2">&quot;torch&quot;</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Recipient should be a worker object not his id.&#39;</span><span class="p">)</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span>
            <span class="n">message</span><span class="o">=</span><span class="n">message</span><span class="p">,</span>
            <span class="n">message_type</span><span class="o">=</span><span class="n">framework</span><span class="o">+</span><span class="s1">&#39;_cmd&#39;</span><span class="p">,</span>
            <span class="n">recipient</span><span class="o">=</span><span class="n">recipient</span>
        <span class="p">)</span>

        <span class="n">response</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="n">worker</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">response</span></div>

<div class="viewcode-block" id="BaseWorker.request_obj"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.request_obj">[docs]</a>    <span class="k">def</span> <span class="nf">request_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_id</span><span class="p">,</span> <span class="n">recipient</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;request_obj(self, obj_id, sender)</span>
<span class="sd">        This method requests that another VirtualWorker send an object to the local one.</span>
<span class="sd">        In the case that the local one is a client,</span>
<span class="sd">        it simply returns the object. In the case that the local worker is not a client,</span>
<span class="sd">        it stores the object in the permanent registry.</span>

<span class="sd">        :Parameters:</span>

<span class="sd">        * **obj_id (str or int)** the id of the object being requested</span>

<span class="sd">        * **sender (** :class:`VirtualWorker` **)** the worker who currently has the</span>
<span class="sd">          object who is being requested to send it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_msg</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="n">obj_id</span><span class="p">,</span>
                               <span class="n">message_type</span><span class="o">=</span><span class="s1">&#39;req_obj&#39;</span><span class="p">,</span>
                               <span class="n">recipient</span><span class="o">=</span><span class="n">recipient</span><span class="p">)</span>

        <span class="nb">object</span> <span class="o">=</span> <span class="n">encode</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">worker</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># for some reason, when returning obj from request_obj method, the gradient</span>
        <span class="c1"># (obj.grad) gets re-initialized without being re-registered and as a</span>
        <span class="c1"># consequence does not have an id, causing the x.grad.id to fail because</span>
        <span class="c1"># it does not exist. As a result, we&#39;ve needed to store objects temporarily</span>
        <span class="c1"># in self._tmpobjects which seems to fix it. Super strange bug which took</span>
        <span class="c1"># multiple days to figure out. The true cause is still unknown but this</span>
        <span class="c1"># workaround seems to work well for now. Anyway, so we need to return a cleanup</span>
        <span class="c1"># method which is called immediately before this is returned to the client.</span>
        <span class="c1"># Note that this is ONLY necessary for the client (which doesn&#39;t store objects</span>
        <span class="c1"># in self._objects)</span>

        <span class="k">return</span> <span class="nb">object</span></div>

<div class="viewcode-block" id="BaseWorker.get_pointer_to"><a class="viewcode-back" href="../../../../modules/syft.core.workers.html#syft.core.workers.base.BaseWorker.get_pointer_to">[docs]</a>    <span class="k">def</span> <span class="nf">get_pointer_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">id_at_location</span><span class="p">):</span>
        <span class="c1"># We keep a dict with keys = owners and subkeys id@loc : self._pointers[location][id@loc] = obj_id</span>
        <span class="c1"># But it has to be updated every time you add, SEND or de_register a pointer</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
            <span class="n">location</span> <span class="o">=</span> <span class="n">location</span><span class="o">.</span><span class="n">id</span>

        <span class="k">if</span> <span class="n">location</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">id_at_location</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span><span class="p">[</span><span class="n">location</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">object_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span><span class="p">[</span><span class="n">location</span><span class="p">][</span><span class="n">id_at_location</span><span class="p">]</span>
                <span class="c1"># Note that the following condition can be false if you send multiple times a pointer,</span>
                <span class="c1"># Because then we don&#39;t de-register the old pointer in self._pointers</span>
                <span class="k">if</span> <span class="n">object_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">object_id</span><span class="p">]</span></div></div>

        <span class="c1"># for key, syft_tensor in self._objects.items():</span>
        <span class="c1">#     if isinstance(syft_tensor, sy._PointerTensor):</span>
        <span class="c1">#         if syft_tensor.location.id == location \</span>
        <span class="c1">#                 and syft_tensor.id_at_location == id_at_location:</span>
        <span class="c1">#             return syft_tensor</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, OpenMined Contributors.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.1',
            LANGUAGE:'python',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>